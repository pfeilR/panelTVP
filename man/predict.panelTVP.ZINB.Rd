% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/S3_predict.R
\name{predict.panelTVP.ZINB}
\alias{predict.panelTVP.ZINB}
\title{Get predictions for new subjects based on a \code{panelTVP.ZINB} object}
\usage{
\method{predict}{panelTVP.ZINB}(
  object,
  X_nb.new,
  X_logit.new,
  timepoint,
  coverage = 0.95,
  pop.pred = FALSE,
  n.replicates = 100,
  ...
)
}
\arguments{
\item{object}{an object of class \code{panelTVP.ZINB}}

\item{X_nb.new}{a matrix or data frame consisting of new data for the same variables
that were used for fitting the model. The first column must contain a 1, when
the fitted model contains an intercept in the Negative Binomial part (count component)}

\item{X_logit.new}{a matrix or data frame consisting of new data for the same variables
that were used for fitting the model. The first column must contain a 1, when
the fitted model contains an intercept in the Logit part (zero-inflation component)}

\item{timepoint}{a numeric scalar indicating the time point for which predictions should
be made, i.e., predictions for a given data set are only made for one specific time point.
In case you want predictions for additional time points you need to repeatedly call this
function.}

\item{coverage}{coverage probability for prediction intervals - defaults to 95 percent coverage}

\item{pop.pred}{logical value, if TRUE population-based predictions are made,
that ignore the random effects structure, if FALSE the random effects structure
is included as well where the unknown factor scores are sampled from their
standard Normal prior - defaults to FALSE}

\item{n.replicates}{number of replicates within each Monte Carlo draw and for each subject
for integrating over the unknown subject-specific factors (ignored when \code{pop.pred = TRUE})}

\item{...}{optional arguments passed to the function (those are ignored)}
}
\value{
a list containing the following elements
\itemize{
\item \code{predictive.distribution}: a matrix where each row contains draws
from the posterior predictive distribution for the corresponding observation.
The number of columns equals the number of MCMC draws when \code{pop.pred = TRUE}
and otherwise is multiplied by \code{n.replicates}, i.e., for each MCMC draw
we have replication draws for marginalizing over the unknown random factors
\item \code{predictive.summary}: posterior mean as well as HPD interval based on
posterior predictive distribution for each new observation
}
}
\description{
This \code{predict} function simulates data and computes summary statistics based on the
posterior predictive distribution for new data under a Zero-Inflated Negative
Binomial likelihood.
}
\examples{
# Predictions based on an object of class panelTVP.ZINB
# NB: To reduce computational effort, we have drastically reduced the length
# of the Markov Chain. You should use a much longer chain in your applications.
sim.zinb <- sim_panelTVP(n = 100,
                         Tmax = 4,
                         beta.nb = c(0.5,-0.7,0,0),
                         theta.nb = c(0.05,0.5,0,0),
                         lambda.nb = 0.5,
                         psi.nb = 0.02,
                         beta.logit = c(-1,0.6,0,0),
                         theta.logit = c(0,1,0,0),
                         lambda.logit = 0.7,
                         psi.logit = 0,
                         r = 2,
                         model = "ZINB")
res.zinb <- panelTVP(y ~ W1.nb + W2.nb + W3.nb | W1.logit + W2.logit + W3.logit,
                     data = sim.zinb$observed,
                     id = sim.zinb$observed$id,
                     t = sim.zinb$observed$t,
                     mcmc.opt = list(chain.length = 200, burnin = 100, thin = 1, asis = TRUE),
                     model = "ZINB")
# setting up design matrix for predicting two new observations
X_nb.new <- data.frame(cbind(c(1,1), # column of 1's for the intercept
                             c(2,0),
                             c(4,3),
                             c(0,0)))
colnames(X_nb.new) <- colnames(res.zinb$data$X_nb)
X_logit.new <- data.frame(cbind(c(1,1), # column of 1's for the intercept
                                c(0.1,-0.5),
                                c(1,2),
                                c(4,3)))
colnames(X_logit.new) <- colnames(res.zinb$data$X_logit)
# prediction for the 2nd panel wave
pp <- predict(res.zinb, X_nb.new = X_nb.new, X_logit.new = X_logit.new, timepoint = 2)
plot(density(pp$predictive.distribution[1,]))
plot(density(pp$predictive.distribution[2,]))
pp$predictive.summary
}
\author{
Roman Pfeiler, Helga Wagner
}
